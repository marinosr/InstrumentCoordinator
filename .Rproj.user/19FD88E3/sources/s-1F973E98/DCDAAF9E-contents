library(shiny)
library(DT)
library(shinyFiles)

# Define UI ----
  ui <- fluidPage(
    titlePanel("Instrument Coordinator"),
    
    sidebarLayout(
      sidebarPanel(strong('Sample Table:'),
                   br(),
                   shinyFilesButton('file', label = 'Load', title=paste('Load a new sample list:'), multiple=FALSE, filetypes='.csv'),
                   br(),
                   actionButton('refresh', 'Reload'),
                   br(),
                   actionButton('import', 'Import'),
                   br(),
                   br(),
                   strong('Run Control:'),
                   br(),
                   actionButton('run', 'Start'),
                   br(),
                   actionButton('stop', 'Stop'),
                   br(),
                   actionButton('goto', 'Go to Sample'),
                   br(),
                   actionButton('kill', 'Kill')
                   ),
      
      mainPanel("main panel",
                DTOutput("control"),
                br()
      )
    )
  )

  # Define server logic ----
  server <- function(input, output, session) {
    
    volumes <- c(Batches = 'C:/Users/Public/InstrumentCoordinator/Batches')
    shinyFileChoose(input, "file", roots = volumes, session = session)
    
    
    
    
    # Monitor changes to BatchControl.dat, and update reactive object if necessary
    control <- reactiveFileReader(1000, session=NULL, filePath='./BatchControl.dat', readFunc=read.csv)
    
    #The observers below are for writing out desired system states to the backend, via batchcontrol.dat, so that it can respond appropriately. 
    
    #Start run observer
    StartObserver <- observeEvent(input$run, {
      controlfile <- read.csv('./Batchcontrol.dat')
      controlfile$Running[1] <- 1
      controlfile$FinishCurrentThenStop[1] <- 0
      controlfile$Kill[1] <- 0
      write.csv(controlfile, './Batchcontrol.dat')
    })
    
    #Killswitch Observer
    KillObserver <- observeEvent(input$kill, {
      controlfile <- read.csv('./Batchcontrol.dat')
      controlfile$Kill[1] <- 1
      controlfile$Running[1] <- 0
      write.csv(controlfile, './Batchcontrol.dat')
    })
    
    #StopAfterCurrent
    StopObserver <- observeEvent(input$stop, {
      controlfile <- read.csv('./Batchcontrol.dat')
      controlfile$FinishCurrentThenStop[1] <- 1
      controlfile$NextSample <- NA
      write.csv(controlfile, './Batchcontrol.dat')
    })
    
    FileChangeObserver <- observe({
      #Parse new filename
      newfile <- parseFilePaths(volumes, input$file)
      #If a new file has been selected, update BatchControl.dat to tell the backend to load a new sample file. 
      if(length(newfile$datapath>0)){
        if(!(control()$BatchFile==newfile$datapath))
        {
          controlfile <- read.csv('./Batchcontrol.dat')
          controlfile$BatchFile[1] <- newfile$datapath
          controlfile$LoadBatch[1] <- 1
          controlfile$Running <- 0
          controlfile$FinishCurrentThenStop[1] <- 0
          controlfile$Kill[1] <- 0
          write.csv(controlfile, './Batchcontrol.dat')
        }
      }
    })
    
    #Monitor changes to file pointed to by batchcontrol.dat and update as necessary. 
    data <- reactiveFileReader(1000, session=NULL, filePath=reactive(control()$BatchFile), readFunc=read.csv)
    
    output$control <- renderDT({
      #Determine the status of all samples
      Status <- character(dim(data())[1])
      #Anything with a timestamp is complete... 
      Status[!(data()$timestamp=='')] <- 'COMPLETE'
      #...Except if it's running
      if(control()$Running==1){
        Status[control()$CurrentSample] <- "RUNNING"
        if(!(is.na(control()$NextSample))){
          Status[control()$NextSample] <- "NEXT"
        }
      } else if(control()$Kill==1) {
        Status[control()$CurrentSample] <- "KILLED"
      }else {
        if(!(is.na(control()$NextSample))){
          Status[control()$NextSample] <- "NEXT"
        }
      }
      
      #Bind the sample list and their statuses and output.
      cbind(Status, data())
    },
    options=list(pageLength=1000, lengthMenu=1000, searching=FALSE, paging=FALSE, ordering=FALSE))
  }

# Run the app ----
shinyApp(ui = ui, server = server)
